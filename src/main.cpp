// #define _BLYNK_VALID // BlynkÊúâÂäπÊúâÁÑ°„Éá„Éê„ÉÉ„Ç∞

#define DEBUG_MODE

#include "private.h"
// #include "history.h"
#include "config.h"

// #define wifiLed 2
#define BLYNK_TEMPLATE_ID "YourTemplateID"
#define BLYNK_TEMPLATE_NAME "YourTemplateName"

// „É©„Ç§„Éñ„É©„É™„ÅÆ„Ç§„É≥„ÇØ„É´„Éº„Éâ
#include <Arduino.h>
#include <ArduinoOTA.h>
#include <EEPROM.h>
#include <Adafruit_INA226.h> // <-- 1. „É©„Ç§„Éñ„É©„É™„Çí„Ç§„É≥„ÇØ„É´„Éº„Éâ
#include <INA226_WE.h>
#include <time.h>
#if defined(ESP8266)
  #include <ESP8266HTTPClient.h>
  #include <BlynkSimpleEsp8266.h>
  #include <ESP8266WiFi.h>
  #include <ESP8266mDNS.h>
  #include <ESP8266HTTPClient.h>
  #include <ESP8266WebServer.h>
  #include <WiFiClientSecureBearSSL.h>
  ESP8266WebServer server(80);
  const char* BOARD_TYPE = "ESP8266";
  const int SOLAR_VOLTAGE_PIN = A0;
  const int SOLAR_CURRENT_PIN = A0;
  const int I2C_SDA_PIN = 4;
  const int I2C_SCL_PIN = 5;
  #define LED_BUILTIN 2
#else
  #include <HTTPClient.h>
  #include <ESP32WebServer.h>
  #include <BlynkSimpleEsp32.h>
  #include <WiFi.h>
  // #include <ESPmDNS.h>
  #include <HTTPClient.h>
  #include <WiFiClientSecure.h>
  #define LED_BUILTIN 2
  ESP32WebServer server(80);
  const char* BOARD_TYPE = "ESP32";
  const int SOLAR_VOLTAGE_PIN = 35;
  const int SOLAR_CURRENT_PIN = 34;
#endif

// Virtual Pin„ÅÆÂÆöÁæ©
#define VPIN_TIME           V10
#define VPIN_MAC            V50
#define VPIN_SOLAR_VOLTAGE  V1
#define VPIN_SOLAR_CURRENT  V1
#define VPIN_SOLAR_POWER    V2
#define VPIN_BATT_VOLTAGE   V3
#define VPIN_BATT_CURRENT   V4
#define VPIN_BATT_POWER     V5
// „Çø„Ç§„Éû„Éº„ÉªÈÅÖÂª∂Ë®≠ÂÆö
const long TIMER_INTERVAL = 5000L;


// --- „Çª„É≥„Çµ„ÉºË®≠ÂÆö ---
const float R1 = 330000.0;
const float R2 = 10000.0;
const float ACS_ZERO_CURRENT_VOLTAGE = 1.65;
const float ACS_SENSITIVITY = 0.040;
const float SHUNT_RESISTANCE_OHMS = 0.00075;
const float MAX_EXPECTED_CURRENT_AMPS = 100.0;

// „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞
BlynkTimer timer;
volatile bool periodTaskTrigger = false;
INA226_WE ina226 = INA226_WE(0x40);
unsigned long lastConnectionAttempt = 0;
const int connectionDelay = 50000;
int dispflag = 0;
char macStr[18];
char iPadd[24];
int timerId = -1;

// WiFiÁä∂ÊÖãÁÆ°ÁêÜ
enum WifiState {
  WIFI_STATE_DISCONNECTED,
  WIFI_STATE_CONNECTING,
  WIFI_STATE_CONNECTED,
  WIFI_STATE_AP_MODE
};
WifiState wifiState = WIFI_STATE_DISCONNECTED;
String st;
String content;
int statusCode;
unsigned long ledBlinkTimer = 0;
unsigned long blinkStartTime = 0;
int blinkCount = 0;
bool isBlinking = false;

// LED„Çπ„ÉÜ„Éº„Çø„ÇπÁÆ°ÁêÜ
enum LedStatus {
  LED_STATUS_WIFI_CONNECTING,      // WiFiÊé•Á∂öÂæÖ„Å° - ÁÇπÁÅØ
  LED_STATUS_AP_MODE,              // WiFiÊé•Á∂ö„Çµ„Éº„Éê„ÉºËµ∑ÂãïÁä∂ÊÖã - Êó©„ÅÑÁÇπÊªÖ
  LED_STATUS_WIFI_CONNECTED,       // WiFiÊé•Á∂öÂÆâÂÆö&BlynkÊé•Á∂öÂæÖ„Å° - „ÇÜ„Å£„Åè„ÇäÁÇπÊªÖ
  LED_STATUS_BLYNK_CONNECTED,      // BLYNKÊé•Á∂öÂÆâÂÆö - Ê∂àÁÅØ
  LED_STATUS_OTA_UPDATE,           // OTAÊõ¥Êñ∞‰∏≠ - ÈùûÂ∏∏„Å´Êó©„ÅÑÁÇπÊªÖ
  LED_STATUS_NO_CONFIG,            // EEPROMË®≠ÂÆö„Å™„Åó - 2ÂõûÁÇπÊªÖÁπ∞„ÇäËøî„Åó
  LED_STATUS_WIFI_FAILED,          // WiFiÊé•Á∂öÂ§±Êïó - 3ÂõûÁÇπÊªÖÁπ∞„ÇäËøî„Åó
  LED_STATUS_BLYNK_RECONNECTING    // BlynkÂÜçÊé•Á∂ö‰∏≠ - 1ÁßíÁÇπÁÅØ‚Üí0.5ÁßíÊ∂àÁÅØ
};
LedStatus currentLedStatus = LED_STATUS_WIFI_CONNECTING;
unsigned long ledStatusTimer = 0;
int ledBlinkCounter = 0;
bool ledState = false;


// Èñ¢Êï∞„Éó„É≠„Éà„Çø„Ç§„ÉóÂÆ£Ë®Ä
// WiFi „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÈñ¢ÈÄ£
bool fetchIPFromGist(int ipData[4]);// GitHub Gist„Åã„Çâ„Ç∞„É≠„Éº„Éê„É´IP„Ç¢„Éâ„É¨„Çπ„ÇíÂèñÂæó„Åô„Çã
void createWebServer();// WiFiË®≠ÂÆöÁî®„ÅÆWeb„Éö„Éº„Ç∏„Çí‰ΩúÊàê„Åó„ÄÅ„É™„ÇØ„Ç®„Çπ„Éà„Å´ÂØæ„Åô„ÇãÂá¶ÁêÜ„ÇíÂÆöÁæ©„Åô„Çã
void manageWifiConnection();// WiFi„Å®Blynk„ÅÆÊé•Á∂öÁä∂ÊÖã„ÇíÁÆ°ÁêÜ„Åô„Çã„É°„Ç§„É≥„ÅÆÈñ¢Êï∞
void setupAP(void);// WiFiË®≠ÂÆöÁî®„ÅÆAP„É¢„Éº„Éâ„ÇíÈñãÂßã„Åó„ÄÅË®≠ÂÆöÁî®Web„Çµ„Éº„Éê„Éº„ÇíËµ∑Âãï„Åô„Çã
void attemptConnectionFromEEPROM();// EEPROM„Åã„ÇâSSID„Å®PW„ÇíË™≠„ÅøÂá∫„ÅóWiFiÊé•Á∂ö„ÇíË©¶„Åø„Çã
void setupOTA();

// -- BlynkÈñ¢ÈÄ£ --
void BlynkConnect();// Blynk„Çµ„Éº„Éê„Éº„Å∏„ÅÆÊé•Á∂öÂá¶ÁêÜ„ÇíË°å„ÅÜ
void aliveReport();// ÂÆöÊúüÁöÑ„Å´ÂÆüË°å„ÅóÁîüÂ≠òÊôÇÂàª„ÇíÂ†±Âëä„Åô„Çã
void reconnectBlynk();// Blynk„Çµ„Éº„Éê„Éº„Åã„ÇâÂàáÊñ≠„Åï„Çå„ÅüÂ†¥Âêà„Å´ÂÜçÊé•Á∂ö„ÇíË©¶„Åø„Çã

// -- „Éè„Éº„Éâ„Ç¶„Çß„Ç¢„Éª„Çª„É≥„Çµ„ÉºÂà∂Âæ° --
void IRAM_ATTR onTimer();// Ââ≤„ÇäËæº„Åø„Çø„Ç§„Éû„Éº„Å´„Çà„Å£„Å¶ÂÆöÊúüÁöÑ„Å´ÂÆüË°å„Åï„Çå„ÇãÈñ¢Êï∞
void updateLedStatus();// ÁèæÂú®„ÅÆÁä∂ÊÖã„Å´Âøú„Åò„Å¶„ÄÅÊú¨‰ΩìLED„ÅÆÁÇπÊªÖ„Éë„Çø„Éº„É≥„ÇíÂà∂Âæ°„Åô„Çã
void setupSensors();//INA226Ë™≠„ÅøÂá∫„Åó„Éù„Éº„Éà„ÅÆÂàùÊúüÂåñ

// -- „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ --
int DisplayTime(char *stringsTime, int *int_h, int *int_m, int *int_s);// NTP„Çµ„Éº„Éê„Éº„Åã„ÇâÂèñÂæó„Åó„ÅüÁèæÂú®ÊôÇÂàª„Çí„ÄåÊôÇ:ÂàÜ:Áßí„Äç„ÅÆÊñáÂ≠óÂàó„Å´Êï¥ÂΩ¢„Åô„Çã
void handleBlinking();
void parseMacAddress(const char* macStr, byte* mac);// MAC„Ç¢„Éâ„É¨„Çπ„ÅÆÊñáÂ≠óÂàó„Çí„Éê„Ç§„ÉàÈÖçÂàó„Å´Â§âÊèõ„Åô„Çã

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  // „Éî„É≥Ë®≠ÂÆö
  pinMode(LED_BUILTIN, OUTPUT);
  
  setupSensors();
  // ÂàùÊúüÁä∂ÊÖãË®≠ÂÆö
  digitalWrite(LED_BUILTIN, HIGH);
  
  // EEPROMÂàùÊúüÂåñ
  EEPROM.begin(512);
  
  // WiFiÂàùÊúüÂåñ
  WiFi.disconnect(true);
  delay(100);
  
  // ÊôÇÂàªË®≠ÂÆö
  configTime(JST, 0, "ntp.nict.jp", "ntp.jst.mfeed.ad.jp");
  
  setupOTA();

  // „Çø„Ç§„Éû„ÉºË®≠ÂÆö
  timer.setInterval(TIMER_INTERVAL, onTimer);
  
  // WiFiÊé•Á∂öÈñãÂßã
  attemptConnectionFromEEPROM();
  
  DEBUG_PRINTLN("Setup completed");
}

void loop() {
  // ÊúÄÂÑ™ÂÖàÂá¶ÁêÜ
  ArduinoOTA.handle();
  handleBlinking();
  
  // LEDÁä∂ÊÖãÊõ¥Êñ∞„ÇíËøΩÂä†
  updateLedStatus();
  
  // WiFi„Å®BlynkÁÆ°ÁêÜ
  manageWifiConnection();
  
  // „Çø„Ç§„Éû„ÉºÂÆüË°å
  timer.run();
}
  
void setupOTA()
{
    // OTAË®≠ÂÆö
  ArduinoOTA.setHostname(HOSTNAME);
  ArduinoOTA.onStart([]() {
    String type;
    if (ArduinoOTA.getCommand() == U_FLASH) {
      type = "sketch";
    } else { // U_SPIFFS
      type = "filesystem";
    }
    currentLedStatus = LED_STATUS_OTA_UPDATE;  // ËøΩÂä†
    DEBUG_PRINTLN("Start updating " + type);
  });
  ArduinoOTA.onEnd([]() {
    DEBUG_PRINTLN("\nEnd");
  });
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    DEBUG_PRINTF("Progress: %u%%\r", (progress / (total / 100)));
  });
  ArduinoOTA.onError([](ota_error_t error) {
    DEBUG_PRINTF("Error[%u]: ", error);
    if (error == OTA_AUTH_ERROR) {
      DEBUG_PRINTLN("Auth Failed");
    } else if (error == OTA_BEGIN_ERROR) {
      DEBUG_PRINTLN("Begin Failed");
    } else if (error == OTA_CONNECT_ERROR) {
      DEBUG_PRINTLN("Connect Failed");
    } else if (error == OTA_RECEIVE_ERROR) {
      DEBUG_PRINTLN("Receive Failed");
    } else if (error == OTA_END_ERROR) {
      DEBUG_PRINTLN("End Failed");
    }
  });
  ArduinoOTA.begin();
}
// WiFiÁÆ°ÁêÜÈñ¢Êï∞
void manageWifiConnection() {
  switch (wifiState) {
    case WIFI_STATE_CONNECTING:
      currentLedStatus = LED_STATUS_WIFI_CONNECTING;  // ËøΩÂä†
      
      if (WiFi.status() == WL_CONNECTED) {
        DEBUG_PRINTLN("\nWiFi Connected!");
        DEBUG_PRINT("IP Address: ");
        DEBUG_PRINTLN(WiFi.localIP());
        wifiState = WIFI_STATE_CONNECTED;
        currentLedStatus = LED_STATUS_WIFI_CONNECTED;  // ËøΩÂä†

        #if defined(_BLYNK_VALID)
        BlynkConnect();
        #endif
      } else if (millis() - lastConnectionAttempt > connectionDelay) {
        DEBUG_PRINTLN("Connection Failed. Starting AP mode.");
        WiFi.disconnect();
        currentLedStatus = LED_STATUS_WIFI_FAILED;  // ËøΩÂä†
        delay(2000);  // Â§±ÊïóÁä∂ÊÖã„Çí2ÁßíË°®Á§∫
        setupAP();
      }
      break;

    case WIFI_STATE_AP_MODE:
      currentLedStatus = LED_STATUS_AP_MODE;  // ËøΩÂä†
      server.handleClient();
      break;

    case WIFI_STATE_CONNECTED:
      if (WiFi.status() != WL_CONNECTED) {
        DEBUG_PRINTLN("WiFi connection lost.");
        wifiState = WIFI_STATE_DISCONNECTED;
        lastConnectionAttempt = millis();
        currentLedStatus = LED_STATUS_WIFI_FAILED;  // ËøΩÂä†
        #if defined(_BLYNK_VALID)
        Blynk.disconnect();
        #endif
      } else {
        #if defined(_BLYNK_VALID)
        if (Blynk.connected()) {
          currentLedStatus = LED_STATUS_BLYNK_CONNECTED;  // ËøΩÂä†
          Blynk.run();
        } else {
          currentLedStatus = LED_STATUS_BLYNK_RECONNECTING;  // ËøΩÂä†
          reconnectBlynk();
        }
        #else
        currentLedStatus = LED_STATUS_WIFI_CONNECTED;  // BlynkÁÑ°ÂäπÊôÇ
        #endif

        if (periodTaskTrigger) {
          periodTaskTrigger = false;
          periodicTasks();
        }
      }
      break;

    case WIFI_STATE_DISCONNECTED:
      DEBUG_PRINTLN("WiFi is disconnected. Reconnecting...");
      WiFi.reconnect();
      wifiState = WIFI_STATE_CONNECTING;
      lastConnectionAttempt = millis();
      currentLedStatus = LED_STATUS_WIFI_CONNECTING;  // ËøΩÂä†
      break;
  }
}

void setupAP(void) {
  WiFi.mode(WIFI_AP_STA);
  delay(100);

  int n = WiFi.scanNetworks();
  if (n == 0) {
    st = "<option value=''>Âà©Áî®ÂèØËÉΩ„Å™„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì</option>";
  } else {
    st = "";
    for (int i = 0; i < n; ++i) {
      String ssid = WiFi.SSID(i);
      int rssi = WiFi.RSSI(i);
      bool isEncrypted;
      
      #if defined(ESP8266)
        isEncrypted = (WiFi.encryptionType(i) != ENC_TYPE_NONE);
      #elif defined(ESP32)
        isEncrypted = (WiFi.encryptionType(i) != WIFI_AUTH_OPEN);
      #endif
      
      st += "<option value='" + ssid + "'>" + ssid + " (" + String(rssi) + "dBm)";
      st += isEncrypted ? " üîí" : " üîì";
      st += "</option>";
    }
  }
  delay(100);

  WiFi.softAP("ESP_WiFi_Setup", "");
  createWebServer();
  server.begin();
  wifiState = WIFI_STATE_AP_MODE;
}

void attemptConnectionFromEEPROM() {
  DEBUG_PRINTLN("Reading EEPROM and attempting to connect...");
  String esid = "";
  for (int i = 0; i < 32; ++i) {
    char c = EEPROM.read(i);
    if (c != 0) esid += c;
  }
  String epass = "";
  for (int i = 32; i < 96; ++i) {
    char c = EEPROM.read(i);
    if (c != 0) epass += c;
  }

  esid.trim();
  epass.trim();

  if (esid.length() > 0) {
    WiFi.mode(WIFI_STA);
    WiFi.begin(esid.c_str(), epass.c_str());
    wifiState = WIFI_STATE_CONNECTING;
    lastConnectionAttempt = millis();
    currentLedStatus = LED_STATUS_WIFI_CONNECTING;  // ËøΩÂä†
    DEBUG_PRINT("Attempting to connect to SSID: ");
    DEBUG_PRINTLN(esid);
  } else {
    DEBUG_PRINTLN("No SSID in EEPROM, starting AP mode.");
    currentLedStatus = LED_STATUS_NO_CONFIG;  // ËøΩÂä†
    delay(3000);  // Ë®≠ÂÆö„Å™„ÅóÁä∂ÊÖã„Çí3ÁßíË°®Á§∫
    setupAP();
  }
}

void createWebServer() {
  server.on("/", []() {
    IPAddress ip = WiFi.softAPIP();
    String ipStr = String(ip[0]) + '.' + String(ip[1]) + '.' + String(ip[2]) + '.' + String(ip[3]);
    content = "<!DOCTYPE HTML>\r\n<html>";
    content += "<head><meta charset='UTF-8'><title>Wi-Fi Settings</title>";
    content += "<style>body{font-family:Arial,sans-serif;margin:20px;background-color:#f0f0f0;}";
    content += ".container{max-width:500px;margin:0 auto;background:white;padding:20px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,0.1);}";
    content += "h2{color:#333;text-align:center;}";
    content += "select,input,button{width:100%;padding:10px;margin:8px 0;border:1px solid #ddd;border-radius:4px;box-sizing:border-box;}";
    content += "button{background-color:#4CAF50;color:white;cursor:pointer;}";
    content += "button:hover{background-color:#45a049;}";
    content += ".refresh-btn{background-color:#008CBA;}";
    content += ".refresh-btn:hover{background-color:#007B9A;}";
    content += "</style></head>";
    content += "<body><div class='container'>";
    content += "<h2>Wi-FiË®≠ÂÆö</h2>";
    content += "<p>SoftAP IP: " + ipStr + "</p>";
    content += "<button class='refresh-btn' onclick='refreshNetworks()'>„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ‰∏ÄË¶ß„ÇíÊõ¥Êñ∞</button>";
    content += "<form method='get' action='setting'>";
    content += "<label for='ssid'>SSID:</label>";
    content += "<select name='ssid' id='ssid' onchange='updateSSID()'>";
    content += "<option value=''>-- „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„ÇíÈÅ∏Êäû --</option>";
    content += st;
    content += "<option value='custom'>-- „Ç´„Çπ„Çø„É†ÂÖ•Âäõ --</option>";
    content += "</select>";
    content += "<input type='text' name='custom_ssid' id='custom_ssid' placeholder='„Ç´„Çπ„Çø„É†SSID„ÇíÂÖ•Âäõ' style='display:none;'>";
    content += "<br><label for='pass'>„Éë„Çπ„ÉØ„Éº„Éâ:</label>";
    content += "<input type='password' name='pass' id='pass' placeholder='WiFi„Éë„Çπ„ÉØ„Éº„Éâ„ÇíÂÖ•Âäõ'>";
    content += "<br><input type='submit' value='Êé•Á∂ö'>";
    content += "</form></div>";
    content += "<script>";
    content += "function updateSSID(){";
    content += "var select=document.getElementById('ssid');";
    content += "var customInput=document.getElementById('custom_ssid');";
    content += "if(select.value==='custom'){customInput.style.display='block';}";
    content += "else{customInput.style.display='none';customInput.value='';}}";
    content += "function refreshNetworks(){";
    content += "window.location.href='/refresh';";
    content += "}";
    content += "</script></body></html>";
    server.send(200, "text/html", content);
  });

  server.on("/refresh", []() {
    // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Çπ„Ç≠„É£„É≥„ÇíÂÜçÂÆüË°å
    int n = WiFi.scanNetworks();
    if (n == 0) {
      st = "<option value=''>Âà©Áî®ÂèØËÉΩ„Å™„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì</option>";
    } else {
      st = "";
      // ‰ø°Âè∑Âº∑Â∫¶„Åß„ÇΩ„Éº„ÉàÔºàÂº∑„ÅÑÈ†ÜÔºâ
      for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
          if (WiFi.RSSI(i) < WiFi.RSSI(j)) {
            // SSID‰∫§Êèõ„ÅØÁõ¥Êé•„Åß„Åç„Å™„ÅÑ„ÅÆ„Åß„ÄÅ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Éô„Éº„Çπ„Åß„ÇΩ„Éº„Éà
          }
        }
      }
      
      for (int i = 0; i < n; ++i) {
        String ssid = WiFi.SSID(i);
        int rssi = WiFi.RSSI(i);
        bool isEncrypted;
        
        #if defined(ESP8266)
          isEncrypted = (WiFi.encryptionType(i) != ENC_TYPE_NONE);
        #elif defined(ESP32)
          isEncrypted = (WiFi.encryptionType(i) != WIFI_AUTH_OPEN);
        #endif
        
        st += "<option value='" + ssid + "'>" + ssid + " (" + String(rssi) + "dBm)";
        st += isEncrypted ? " üîí" : " üîì";
        st += "</option>";
      }
    }
    
    // „É™„ÉÄ„Ç§„É¨„ÇØ„Éà„Åó„Å¶„É°„Ç§„É≥„Éö„Éº„Ç∏„ÇíÂÜçË°®Á§∫
    server.sendHeader("Location", "/");
    server.send(302, "text/plain", "");
  });

  server.on("/setting", []() {
    String qsid = server.arg("ssid");
    String customSsid = server.arg("custom_ssid");
    String qpass = server.arg("pass");
    
    // „Ç´„Çπ„Çø„É†SSID„ÅåÂÖ•Âäõ„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„Åù„Å°„Çâ„ÇíÂÑ™ÂÖà
    if (customSsid.length() > 0) {
      qsid = customSsid;
    }
    
    if (qsid.length() > 0 && qpass.length() > 0) {
      DEBUG_PRINTLN("Clearing EEPROM");
      for (int i = 0; i < 96; ++i) {
        EEPROM.write(i, 0);
      }
      DEBUG_PRINTLN("Writing new credentials to EEPROM:");
      DEBUG_PRINTLN(qsid);
      
      for (int i = 0; i < qsid.length(); ++i) {
        EEPROM.write(i, qsid[i]);
      }
      for (int i = 0; i < qpass.length(); ++i) {
        EEPROM.write(32 + i, qpass[i]);
      }
      EEPROM.commit();

      content = "<!DOCTYPE HTML><html><head><meta charset='UTF-8'></head><body>";
      content += "<h2>Ë®≠ÂÆöÂÆå‰∫Ü</h2><p>WiFiË®≠ÂÆö„Åå‰øùÂ≠ò„Åï„Çå„Åæ„Åó„Åü„ÄÇ„Éá„Éê„Ç§„Çπ„ÇíÂÜçËµ∑Âãï„Åó„Åæ„Åô...</p>";
      content += "<script>setTimeout(function(){alert('„Éá„Éê„Ç§„Çπ„ÅåÂÜçËµ∑Âãï„Åï„Çå„Åæ„Åô');},2000);</script>";
      content += "</body></html>";
      server.send(200, "text/html", content);
      delay(2000);
      ESP.restart();
    } else {
      content = "<!DOCTYPE HTML><html><head><meta charset='UTF-8'></head><body>";
      content += "<h2>„Ç®„É©„Éº</h2><p>SSID„Åæ„Åü„ÅØ„Éë„Çπ„ÉØ„Éº„Éâ„ÅåÂÖ•Âäõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ</p>";
      content += "<a href='/'>Êàª„Çã</a></body></html>";
      server.send(400, "text/html", content);
    }
  });
}

// BlynkÈñ¢ÈÄ£Èñ¢Êï∞
void BlynkConnect() {
  #if defined(_BLYNK_VALID)
  IPAddress localIP = WiFi.localIP();
  IPAddress ServerIPAddr;
  String ipString = localIP.toString();
  String leftThreeChars = ipString.substring(0, 3);

  if(leftThreeChars.equals("192")) {
    ServerIPAddr = SERVER_IP_LOCAL;
  } else {
    int ipData[4];
    if(fetchIPFromGist(ipData)) {
      ServerIPAddr = IPAddress(ipData[0], ipData[1], ipData[2], ipData[3]);
      DEBUG_PRINTF("global ip add: %d:%d:%d:%d\n",ipData[0], ipData[1], ipData[2], ipData[3]);
    } else {
      ESP.restart();
    }
  }
  
  for(int i = 0; i < 5; i++) {
    Blynk.config(AUTH, ServerIPAddr, 8080);
    DEBUG_PRINTLN("Blynk.config(AUTH, ServerIPAddr, 8080) executed.");
    DEBUG_PRINTF("AUTH : %s",AUTH);
    DEBUG_PRINTF("     ServerIPAddr : %s\n",ServerIPAddr);

    delay(10);
    if(Blynk.connect()) {
      break;
    }
  }
  #endif
}

void reconnectBlynk() {
  #if defined(_BLYNK_VALID)
  if (Blynk.connect()) {
    DEBUG_PRINTLN("Reconnected to Blynk!");
  } else {
    DEBUG_PRINTLN("Reconnection to Blynk failed.");
  }
  delay(5000);
  #endif
}

// Blynk„Ç≥„Éº„É´„Éê„ÉÉ„ÇØÈñ¢Êï∞
#if defined(_BLYNK_VALID)
BLYNK_CONNECTED() {
  Blynk.syncAll();
  delay(1);
  aliveReport();
  
  uint8_t mac[6];
  WiFi.macAddress(mac);
  sprintf(macStr, "%02X:%02X:%02X:%02X:%02X:%02X", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  
  IPAddress ipaddr = WiFi.localIP();
  sprintf(iPadd, "%d.%d.%d.%d", ipaddr[0], ipaddr[1], ipaddr[2], ipaddr[3]);
  
  Blynk.setProperty(VPIN_MAC, "offLabel", DeviceName);
  Blynk.setProperty(VPIN_TIME, "offLabel", String("V") + FirmwareVersion);
  dispflag = 0;
  Blynk.virtualWrite(VPIN_MAC, 0);
  delay(1);
}

BLYNK_WRITE(VPIN_MAC) {
  DEBUG_PRINTLN("VPIN_MAC pushed.")
  if (timerId != -1) {
    timer.deleteTimer(timerId);
  }
  
  switch (dispflag) {
    case 0:
      Blynk.setProperty(VPIN_MAC, "offLabel", DeviceName);
      break;
    case 1:
      Blynk.setProperty(VPIN_MAC, "offLabel", String("V") + FirmwareVersion);
      break;
    case 2:
      Blynk.setProperty(VPIN_MAC, "offLabel", iPadd);
      break;
    case 3:
      Blynk.setProperty(VPIN_MAC, "offLabel", macStr);
      break;
  }
  if(dispflag >= 3){
    dispflag = 0;
  }else{
    dispflag ++;
  }

  timerId = timer.setTimeout(5000, []() {
    dispflag = 0;
    Blynk.setProperty(VPIN_MAC, "offLabel", DeviceName);
    delay(1);
  });
}

#endif

// „Çø„Ç§„Éû„ÉºÈñ¢Êï∞
void IRAM_ATTR onTimer() {
  periodTaskTrigger = true;
}

// ÁîüÂ≠òÂ†±ÂëäÈñ¢Êï∞
void aliveReport() {
  #if defined(_BLYNK_VALID)
  char str[30];
  if(!Blynk.connected()) {
    return;
  }
  
    int int_h, int_m, int_s;
    int sec = DisplayTime(str, &int_h, &int_m, &int_s);
    
    Blynk.setProperty(VPIN_TIME, "offLabel", str);
    DEBUG_PRINTLN("VPIN_TIME writed.")

    delay(1);
    
    if (sec % 30 < TIMER_INTERVAL / 1000) {  
      String colorText;
      sec >= 30 ? colorText = "#00FFFF" : colorText = "#FFA500";
      Blynk.setProperty(VPIN_TIME, "offBackColor", colorText.c_str());
      delay(1);
    }
  #endif
}

void handleBlinking() {
  if (!isBlinking) {
    return;
  }

  if (millis() - blinkStartTime >= 100) {
    blinkStartTime = millis();
    blinkCount--;
    if (blinkCount <= 0) {
      isBlinking = false;
      digitalWrite(LED_BUILTIN, HIGH);
    } else {
      digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));
    }
  }
}

// ÊôÇÂàªË°®Á§∫Èñ¢Êï∞
int DisplayTime(char *stringsTime, int *int_h, int *int_m, int *int_s) {
  struct tm tminfo;
  
  if (!getLocalTime(&tminfo)) {
    sprintf(stringsTime, "00:00:00");
    *int_h = 0; *int_m = 0; *int_s = 0;
    return 0;
  }
  
  *int_h = tminfo.tm_hour;
  *int_m = tminfo.tm_min;
  *int_s = tminfo.tm_sec;
  sprintf(stringsTime, "%02d:%02d:%02d", tminfo.tm_hour, tminfo.tm_min, tminfo.tm_sec);
  return tminfo.tm_sec;
}

bool fetchIPFromGist(int ipData[4]) {
  if (WiFi.status() != WL_CONNECTED) {
    DEBUG_PRINTLN("WiFi not connected.");
    return false;
  }

  #if defined(ESP8266)
  std::unique_ptr<BearSSL::WiFiClientSecure> client(new BearSSL::WiFiClientSecure());
  client->setInsecure();
  HTTPClient http;
  String url = "https://gist.githubusercontent.com/" + String(myName) + "/" + GIST_TOKEN + "/raw/global_ip.txt";
  http.begin(*client, url.c_str());
  #else
  WiFiClientSecure client;
  client.setInsecure();
  HTTPClient http;
  String url = "https://gist.githubusercontent.com/" + String(myName) + "/" + GIST_TOKEN + "/raw/global_ip.txt";
  http.begin(client, url.c_str());
  #endif

  int httpCode = http.GET();
  if (httpCode != 200) {
    DEBUG_PRINTF("HTTP GET failed: %s\n", http.errorToString(httpCode).c_str());
    http.end();
    return false;
  }

  String ip = http.getString();
  ip.trim();
  DEBUG_PRINTF("Fetched IP: %s\n", ip.c_str());

  int start = 0;
  for (int i = 0; i < 4; i++) {
    int end = ip.indexOf('.', start);
    String part;

    if (i < 3) {
      if (end == -1) {
        DEBUG_PRINTLN("Invalid IP format (dot missing).");
        http.end();
        return false;
      }
      part = ip.substring(start, end);
      start = end + 1;
    } else {
      part = ip.substring(start);
    }

    ipData[i] = part.toInt();
    if (ipData[i] < 0 || ipData[i] > 255) {
      DEBUG_PRINTF("Invalid IP segment: %d\n", ipData[i]);
      http.end();
      return false;
    }
  }

  http.end();
  return true;
}

void parseMacAddress(const char* macStr, byte* mac) {
  sscanf(macStr, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);
}
// LEDÂà∂Âæ°Èñ¢Êï∞
void updateLedStatus() {
  unsigned long currentTime = millis();
  
  switch (currentLedStatus) {
    case LED_STATUS_WIFI_CONNECTING:
      // WiFiÊé•Á∂öÂæÖ„Å° - Â∏∏ÊôÇÁÇπÁÅØ
      digitalWrite(LED_BUILTIN, LOW);  // LOW = ÁÇπÁÅØ
      break;
      
    case LED_STATUS_AP_MODE:
      // WiFiÊé•Á∂ö„Çµ„Éº„Éê„ÉºËµ∑ÂãïÁä∂ÊÖã - Êó©„ÅÑÁÇπÊªÖÔºà100msÈñìÈöîÔºâ
      if (currentTime - ledStatusTimer > 300) {
        ledState = !ledState;
        digitalWrite(LED_BUILTIN, ledState ? HIGH : LOW);
        ledStatusTimer = currentTime;
      }
      break;
      
    case LED_STATUS_WIFI_CONNECTED:
      // WiFiÊé•Á∂öÂÆâÂÆö&BlynkÊé•Á∂öÂæÖ„Å° - „ÇÜ„Å£„Åè„ÇäÁÇπÊªÖÔºà1ÁßíÈñìÈöîÔºâ
      if (currentTime - ledStatusTimer > 1000) {
        ledState = !ledState;
        digitalWrite(LED_BUILTIN, ledState ? HIGH : LOW);
        ledStatusTimer = currentTime;
      }
      break;
      
    case LED_STATUS_BLYNK_CONNECTED:
      // BLYNKÊé•Á∂öÂÆâÂÆö - Ê∂àÁÅØ
      digitalWrite(LED_BUILTIN, HIGH);  // HIGH = Ê∂àÁÅØ
      break;
      
    case LED_STATUS_OTA_UPDATE:
      // OTAÊõ¥Êñ∞‰∏≠ - ÈùûÂ∏∏„Å´Êó©„ÅÑÁÇπÊªÖÔºà50msÈñìÈöîÔºâ
      if (currentTime - ledStatusTimer > 50) {
        ledState = !ledState;
        digitalWrite(LED_BUILTIN, ledState ? HIGH : LOW);
        ledStatusTimer = currentTime;
      }
      break;
      
    case LED_STATUS_NO_CONFIG:
      // EEPROMË®≠ÂÆö„Å™„Åó - 2ÂõûÁÇπÊªÖÁπ∞„ÇäËøî„Åó
      if (currentTime - ledStatusTimer > 200) {
        if (ledBlinkCounter < 4) {  // 2ÂõûÁÇπÊªÖ = 4Âõû„ÅÆÁä∂ÊÖãÂ§âÂåñ
          ledState = !ledState;
          digitalWrite(LED_BUILTIN, ledState ? HIGH : LOW);
          ledBlinkCounter++;
        } else if (ledBlinkCounter < 20) {  // 1ÁßíÈñì‰ºëÊ≠¢
          digitalWrite(LED_BUILTIN, HIGH);
          ledBlinkCounter++;
        } else {
          ledBlinkCounter = 0;  // „É™„Çª„ÉÉ„Éà„Åó„Å¶Áπ∞„ÇäËøî„Åó
        }
        ledStatusTimer = currentTime;
      }
      break;
      
    case LED_STATUS_WIFI_FAILED:
      // WiFiÊé•Á∂öÂ§±Êïó - 3ÂõûÁÇπÊªÖÁπ∞„ÇäËøî„Åó
      if (currentTime - ledStatusTimer > 200) {
        if (ledBlinkCounter < 6) {  // 3ÂõûÁÇπÊªÖ = 6Âõû„ÅÆÁä∂ÊÖãÂ§âÂåñ
          ledState = !ledState;
          digitalWrite(LED_BUILTIN, ledState ? HIGH : LOW);
          ledBlinkCounter++;
        } else if (ledBlinkCounter < 20) {  // 1ÁßíÈñì‰ºëÊ≠¢
          digitalWrite(LED_BUILTIN, HIGH);
          ledBlinkCounter++;
        } else {
          ledBlinkCounter = 0;  // „É™„Çª„ÉÉ„Éà„Åó„Å¶Áπ∞„ÇäËøî„Åó
        }
        ledStatusTimer = currentTime;
      }
      break;
      
    case LED_STATUS_BLYNK_RECONNECTING:
      // BlynkÂÜçÊé•Á∂ö‰∏≠ - 1ÁßíÁÇπÁÅØ‚Üí0.5ÁßíÊ∂àÁÅØ
      if (ledState && (currentTime - ledStatusTimer > 1000)) {
        ledState = false;
        digitalWrite(LED_BUILTIN, HIGH);
        ledStatusTimer = currentTime;
      } else if (!ledState && (currentTime - ledStatusTimer > 500)) {
        ledState = true;
        digitalWrite(LED_BUILTIN, LOW);
        ledStatusTimer = currentTime;
      }
      break;
  }
}
// =============================================================================
// 8. ÂÆöÊúüÂÆüË°å„Çø„Çπ„ÇØ (5Áßí„Åî„Å®„Å´ÂÆüË°å)
// =============================================================================
void periodicTasks() {
  Serial.println("\n----- ÂÆöÊúü„Çø„Çπ„ÇØÂÆüË°å -----");
  measureSolar();
  measureBattery();
  // „Åì„Åì„Å´ÂÖÉ„ÅÆ`aliveReport`„ÅÆ‰ªñ„ÅÆÂá¶ÁêÜÔºàÊôÇÂàªË°®Á§∫Êõ¥Êñ∞„Å™„Å©Ôºâ„ÇíÁßªÊ§ç
  aliveReport();
}